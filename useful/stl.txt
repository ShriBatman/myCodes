Containers:

Vectors:
-----------------------------------------------------------------------------------------------------------------------------------------------------

* when pass a vector to a function a copy of that vector is passed which is inefficient so pass them as reference. 

*multidimensional vectors:
vector< vector< int > > Matrix(N, vector< int >(M, -1));\

* we can use resize() to remove some of the elements from the back of the vector or add elements.
when we increase the size of the vector the newly added memory is initialized with zeros.
so using push_back() will further increase the size beyond those zero initialized elements.
if we want to write on those elements use: v[i] = ...; not the push_back() function.

assignment:
------------------
c = c2                                   Assigns all elements of c2 to c
c.fill(val)                            Assigns val to each element in array c
c1.swap(c2)                      Swaps the data of c1 and c2
swap(c1,c2)                      Swaps the data of c1 and c2


access:
----------
c[idx]                       Returns the element with index idx (no range checking)
c.at(idx)                  Returns the element with index idx (throws range-error exception if idx is out of range)
c.front()                  Returns the first element (no check whether a first element exists)




Pair:
-----------------------------------------------------------------------------------------------------------------------------------------------

pair<T1,T2> p	 	Default constructor; creates a pair of values of types T1 and T2, initialized with their default constructors
pair<T1,T2> p(val1,val1) 	Creates a pair of values of types T1 and T2, initialized with val1 and val1
pair<T1,T2> p(p2)		 Copy constructor; creates p as copy of p2
p = p2 			Assigns the values of p2 to p (implicit type conversions are possible since C++11)
p.first 			Yields the first value inside the pair (direct member access)
p.second 			Yields the second value inside the pair (direct member access)
get<0>(p) 			Equivalent to p.first (since C++11)
get<1>(p) 			Equivalent to p.second (since C++11)
p1 == p2 			Returns whether p1 is equal to p2 (equivalent to p1.first==p2.first && p1.second==p2.second)
p1 != p2 			Returns whether p1 is not equal to p2 (!(p1==p2)) p1 < p2 Returns whether p1 is less than p2 (compares first or if equal second of both values)
p1.swap(p2)		 Swaps the data of p1 and p2 (since C++11)
swap(p1,p2) 		Same (as global function) (since C++11)
make_pair(val1,val2)	 Returns a pair with types and values of val1 and val2



Set:
-----------------------------------------------------------------------------------------------------------------------------------------------

Initialize:
set<int> s;
int data[5] = {...........}
set<int> s(data,data+5);

Basic operations:
s.insert(x);
s.erase(x);
s.erase(it1,it2)
s.size();


Traverse:
is not a linear container. use iterators to traverse.

for(set<int>::const_iterator it = s.begin(); it! = s.end(); it++){
.............
}

useful macros:
#define tr(container, it)  for(typeof(container.begin()) it = container.begin(); it != container.end(); it++)
int r = 0;
tr(v, it) {
r += (it)(*it);
}

set< pair< string, pair< int, vector< int > > > SS;
int total = 0;
tr(SS, it) {
total += it->second.first;
}



#define all(c) c.begin(), c.end()
#define present(container, element) (container.find(element) != container.end())
#define cpresent(container, element) (find(all(container),element) != container.end())

present is for set and maps while cpresent is for vector.


Check presence of an element:
s.find(x)   returns s.end if not present elese iterator to the element in O(logN).
s.count(x) counts the no. of occurences of the element x in s in O(logN).


*Internally map and set are almost always stored as red-black trees.
*the elements of map and set are always sorted in ascending order while traversing these containers.
*that set and map have the member functions find() and count(), which works in O(log N), while std::find() and std::count() take O(N)
* .size() to find the no of elements in a set or map.

Map
-----------------------------------------------------------------------------------------------------------------------------------------------

initialize:
map<string,int> m;
m["sdf"] = 5;
theMap.insert( make_pair( "Key 1", -1 ) ); 
theMap.insert( make_pair( "Another key!", 32 ) ); 



if(M.find("SRM") != M.end()) {
M.erase(M.find("SRM")); // or even M.erase("SRM")
}


void f(const map< string, int >& M) {
if(M["the meaning"] == 42) { // Error! Cannot use [] on const map objects!
}
if(M.find("the meaning") != M.end() && M.find("the meaning")->second == 42) { // Correct
cout << "Don't Panic!" << endl;
}
}

Arrays:
--------------------------------------------------------------------------------------------------------
static C style arrays
sequence of elements with constant size
can neither add nor remove elements to change the size
only a replacement of element values is possible
Arrays provide random access : access every element directly in constant time

the default constructor does not create an empty container
only container whose elements are default initialized when nothing is passed to initialize the elements.
for fundamental types, the initial value might be undefined rather than zero
std::array<int,4> x;                          // elements of x have undefined value

can provide an empty initializer list
elements of fundamental types are zero initialized
std::array<int,4> x = {};                    //all elements of x have value 0 (int())

The elements in the initializer list must have the same type, or there must be a type conversion to the
element type of the array defined.

If an initializer list does not have enough elements, it is guaranteed that for fundamental data
types the elements are zero initialized
std::array<int,10> c2 = { 42 };            // one element with value 42 followed by 9 elements with value 0


If the number of elements in the initializer lists is higher than the size of the array, the expression is
ill-formed:
std::array<int,5> c3 = { 1, 2, 3, 4, 5, 6 };                       // ERROR: too many values

possible to specify a size of 0
begin() and end(), cbegin() and cend(), and the corresponding reverse iterators still 
yield the same unique value
return value of front() and back() is undefined.


initialize:
------------
array<Elem,N> c                        Default constructor; creates an array with defaultinitialized elements
array<Elem,N> c(c2)                Copy constructor; creates a copy of another array of the same type (all elements are copied)
array<Elem,N> c = c2               Copy constructor; creates a copy of another array of the same type (all elements are copied)
array<Elem,N> c = initlist      Creates an array initialized with the elements of the initializer list

operators:
-------------
c.empty()                  Returns whether the container is empty (equivalent to size()==0 but might be faster)
c.size()                       Returns the current number of elements
c.max_size()            Returns the maximum number of elements possible
c1 == c2                      Returns whether c1 is equal to c2 (calls == for the elements)
c1 != c2                       Returns whether c1 is not equal to c2 (equivalent to !(c1==c2))
c1 < c2                         Returns whether c1 is less than c2
c1 > c2                         Returns whether c1 is greater than c2 (equivalent to c2<c1)
c1 <= c2                       Returns whether c1 is less than or equal to c2 (equivalent to !(c2<c1))
c1 >= c2                       Returns whether c1 is greater than or equal to c2 (equivalent to !(c1<c2))



assignment:
---------------
c = c2                                   Assigns all elements of c2 to c
c.fill(val)                            Assigns val to each element in array c
c1.swap(c2)                      Swaps the data of c1 and c2
swap(c1,c2)                      Swaps the data of c1 and c2


access:
----------
c[idx]                       Returns the element with index idx (no range checking)
c.at(idx)                  Returns the element with index idx (throws range-error exception if idx is out of range)
c.front()                  Returns the first element (no check whether a first element exists)
c.back()                   Returns the last element (no check whether a last element exists)




Dumb Dumb Me!!
---------------------------------------------------------------------------------------------------------------------------------------------

i++ : increments thevalue of i but returns the original value of i before increment.
//j=i++; i=2, j=1
 
++i : increments the value and returns the incremented value
//j=++i; i=2,j=2

CONST:
*is a type qualifier. A type qualifier is used to express additional info about a value through type system. When a variable is initialized using the const type qualifier, it will not accept further change in its value.

*if a variable is const the we cannot change its value.(compilation occurs).but we can use pointer to change its value.
    const int i = 0;
    int *ptr = &i;
    *ptr = 990;
    cout<<i;     //990

int const *ptr;
a pointer to const can be made to point to any variable but we cannot change the value of the variable 
using the pointer.


int *const ptr;
a constant pointer can be used to change the value of the variable but we cannot change the variable
it points to.

const int *const ptr;
we cannot change the variable ptr is pointing to as well as cannot change the value of the variable using ptr.

const member function:
    class Test{
        int get() const{ return x;}
    }

a const member function does not allows the function the object its begin called on.
a const object can call both type of functions const/ non const but a non const object can only call non const member functions.


STATIC: is a storage specifier.
*determines the lifetime and visibility/accessibility of the variable. This means if a variable is declared as a static variable, it will remain in the memory the whole time when the program is running.

static data_type var = value;

*static variables stay in memory even after they are out of the scope.
    #include<stdio.h> 
    int fun() 
    { 
      static int count = 0; 
      count++; 
      return count; 
    }   
    int main() 
    { 
      printf("%d ", fun()); 
      printf("%d ", fun()); 
      return 0; 
    }

    output: 1 2

*static variables are allocated memory in data segment not the stack.
*static vars like global vars are initialized with zero if not explicitly initialized.

*in C static vars can only be initialized using constant literals (cannot initialized using functions).(not true for c++).

    #include<stdio.h> 
    int initializer(void) 
    { 
        return 50; 
    } 
    int main() 
    { 
        static int i = initializer(); 
        printf(" value of i = %d", i); 
        getchar(); 
        return 0; 
    }
    output:
    In function 'main':
    9:5: error: initializer element is not constant
         static int i = initializer();
         ^


* a static const var will retain its value till the execution of the program and also, it will not accept any change in its value


Preprocessors:
*all lines that start with # are processed by preprocessor which is a special program invoked by the compiler.


#define And Macros:
*it sets up a macro. A macro causes a text to replace before compilation takes place.
*Macros are pre-processed which means that all the macros would be processed before your program compiles.
*Macros are typically faster than functions as they don’t involve actual function call overhead.
*In macros, no type checking(incompatible operand, etc.) is done and can lead to errors/side-effects. Also, macros do not check for compilation error (if any).
    #include<stdio.h> 
    #define CUBE(b) b*b*b 
    int main() 
    { 
         printf("%d", CUBE(1+2)); 
         return 0; 
    }
    Output: Unexpected output.





Things I Get Confused with:
---------------------------------------------------------------------------------------------------------------------------------------------

//passing a 2d array to a function:

    void func(int row,int col, int arr[row][col]){
    ...
    }
    int main(){
    func(row,col,arr);
    }


    void func(int **arr, int row ,int col){.....}
    int main(){
    int **arr; // is the pointer to the 2d array;
    func(arr,row,col);
    }



Pointer to pointer:
//not valid
    int **ptr = &&value

//valid
    int *ptr = &value;
    int **ptrptr  = &ptr;
    cout<<**ptrptr;
    int **ptr = nullptr;

//arrays of pointer
    int **arr = new int*[10];
    int *p;
    arr[0] = p;
    cout<<*arr[i];

//2D dynamically allocated arrays
    int **array = new int*[10]; // allocate an array of 10 int pointers — these are our rows
    for (int count = 0; count < 10; ++count)
        array[count] = new int[5]; // these are our columns

//passing arrays
When passing an array as an argument to a function, a fixed array decays into a pointer, and the pointer is passed to the function.
    void printSize(int *array)
    {
        // array is treated as a pointer here
        std::cout << sizeof(array) << '\n'; // prints the size of a pointer, not the size of the array!
    }
    int main()
    {
        printSize(array); // the array argument decays into a pointer here
    }


// C++ will implicitly convert parameter array[] to *array
    void printSize(int array[])
    {
        // array is treated as a pointer here, not a fixed array
        std::cout << sizeof(array) << '\n'; // prints the size of a pointer, not the size of the array!
    }
    int main()
    {
        printSize(array); // the array argument decays into a pointer here
    }

*The fact that arrays decay into pointers when passed to a function explains the underlying reason why 
  changing an array in a function changes the actual array argument passed in.
*it is worth noting that arrays that are part of structs or classes do not decay when the whole struct or class is passed to a function.


//pass by address
    void foo(int *ptr)
    {
        *ptr = 6;
    } 
    int main()
    {
        int value = 5;
     
        std::cout << "value = " << value << '\n'; //out 5
        foo(&value);
        std::cout << "value = " << value << '\n'; // out 6
        return 0;
    }

use const if the function doesn't need to modify the variable/array.

Addresses are actually passed by value

When you pass a pointer to a function by address, the pointer’s value (the address it points to) is copied from the argument to the function’s parameter.  
If you change the function parameter’s value, you are only changing a copy. Consequently, the original pointer argument will not be changed.

    void setToNull(int *tempPtr)
    {
        // we're making tempPtr point at something else, not changing the value that tempPtr points to.
        tempPtr = nullptr; // use 0 instead if not C++11
    } 
    int main()
    { 
        // First we set ptr to the address of five, which means *ptr = 5
        int five = 5;
        int *ptr = &five;
    	
        // This will print 5
        std::cout << *ptr;
     
        // tempPtr will receive a copy of ptr
        setToNull(ptr);
     
        // ptr is still set to the address of five!
     
        // This will print 5
        if (ptr)
            std::cout << *ptr;
        else
            std::cout << " ptr is null";
     
        return 0;
    }

When passing an argument by address, the function parameter variable receives a copy of the address from the argument. 
At this point, the function parameter and the argument both point to the same value.

If the function parameter is then dereferenced to change the value being pointed to, that will impact the value the argument is pointing to, 
since both the function parameter and argument are pointing to the same value!

If the function parameter is assigned a different address, that will not impact the argument, since the function parameter is a copy, 
and changing the copy won’t impact the original. 
After changing the function parameter’s address, the function parameter and argument will point to different values, 
so dereferencing the parameter and changing the value will no longer affect the value pointed to by the argument.



//rvalues and lvalues:
l-values are objects that have a defined memory address (such as variables), and persist beyond a single expression.
r-values are temporary values that do not have a defined memory address, and only have expression scope.
R-values include both the results of expressions (e.g. 2 + 3) and literals.


//references
References generally act identically to the values they’re referencing. In this sense, a reference acts as an alias for the object being referenced.
    int x = 5; // normal integer
    int &y = x; // y is a reference to x
    int &z = y; // z is also a reference to x

Using the address-of operator on a reference returns the address of the value being referenced:
    cout << &value; // prints 0012FF7C
    cout << &ref; // prints 0012FF7C

References must be initialized.no such thing as a null reference.
    int value = 5;
    int &ref = value; // valid reference, initialized to variable value
    int &invalidRef; // invalid, needs to reference something

references cannot be reassigned.
    int value1 = 5;
    int value2 = 6;
 
    int &ref = value1; // okay, ref is now an alias for value1
    ref = value2; // assigns 6 (the value of value2) to value1 -- does NOT change the reference!
Instead of reassigning ref to reference variable value2, it instead assigns the value from value2 to value1 (which ref is a reference of)

//using references to pass arrays to function
// Note: You need to specify the array size in the function declaration
    void printElements(int (&arr)[4])
    {
    ..........
    }
    int main()
    {
        printElements(arr);
    }

//Limitations of pass by reference
Non-const references can only reference non-const l-values (e.g. non-const variables), 
so a reference parameter cannot accept an argument that is a const l-value or an r-value (e.g. literals and the results of expressions).


//pass by const reference:
const reference is a reference that does not allow the variable being referenced to be changed through the reference.
Consequently, if we use a const reference as a parameter, we guarantee to the caller that the function will not change the argument!

    void foo(const int &x) // x is a const reference
    { x = 6;  // compile error: a const reference cannot have its value changed!}

Const references can accept any type of argument, including l-values, const l-values, and r-values.

//references to pointer
    void foo(int *&ptr) // pass pointer by reference
    {ptr = nullptr; // this changes the actual ptr argument passed in, not a copy}






ALGORITHM:
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. The _if suffix is used when you can call two forms of an algorithm that have the same number of parameters either by passing a value or by passing a function or function object. In this case,
the version without the suffix is used for values, and the version with the _if suffix is used for functions and function objects. For example, find() searches for an element that has a certain
value, whereas find_if() searches for an element that meets the criterion passed as a function, a function object, or a lambda.

2. The _copy suffix is used as an indication that elements are not only manipulated but also copied into a destination range. For example, reverse() reverses the order of elements inside a range,
whereas reverse_copy() copies the elements into another range in reverse order.


Nonmodifying algos:
--------------------------
Nonmodifying algorithms change neither the order nor the value of the elements they process. These algorithms operate with input and forward iterators; therefore, you can call them for all standard containers.


for_each() 			Performs an operation for each element
count()				 Returns the number of elements
count_if()				 Returns the number of elements that match a criterion
min_element() 			Returns the element with the smallest value 
max_element() 			Returns the element with the largest value
minmax_element() 			Returns the elements with the smallest and largest value (since C++11)
find() 				Searches for the first element with the passed value
find_if()				 Searches for the first element that matches a criterion
find_if_not() 			Searches for the first element that matches a criterion not (since C++11)
search_n()			 Searches for the first n consecutive elements with certain properties
search() 				Searches for the first occurrence of a subrange
find_end() 			Searches for the last occurrence of a subrange
find_first_of()			 Searches the first of several possible elements
adjacent_find() 			Searches for two adjacent elements that are equal (by some criterion)
equal() 				Returns whether two ranges are equal
is_permutation() 			Returns whether two unordered ranges contain equal elements (since C++11)
mismatch() 			Returns the first elements of two sequences that differ 
lexicographical_compare() 		Returns whether a range is lexicographically less than another range 
is_sorted() 			Returns whether the elements in a range are sorted (since C++11)
is_sorted_until() 			Returns the first unsorted element in a range (since C++11)
is_partitioned() 			Returns whether the elements in a range are partitioned in two groups according to a criterion (since C++11)
partition_point() 			Returns the partitioning element for a range partitioned into elements fulfilling and elements not fulfilling a predicate (since C++11)
is_heap() 				Returns whether the elements in a range are sorted as a heap (since C++11)
is_heap_until() 			Returns the first element in a range not sorted as a heap (since C++11)
all_of() 				Returns whether all elements match a criterion (since C++11) 
any_of() 				Returns whether at least one element matches a criterion(since C++11)
none_of() 			Returns whether none of the elements matches a criterion(since C++11)

Search for 				String Function 		STL Algorithm
First occurrence of one element 		find() 			find()
Last occurrence of one element 		rfind() 			find() with reverse iterators
First occurrence of a subrange 			find() 			search()
Last occurrence of a subrange 			rfind() 			find_end()
First occurrence of several elements 		find_first_of() 		find_first_of()
Last occurrence of several elements 		find_last_of() 		find_first_of() with reverse iterators
First occurrence of n consecutive					search_n()
elements


Modifying algos:
---------------------
Modifying algorithms change the value of elements. Such algorithms might modify the elements of a range directly or modify them while they are being copied into another range. If elements are
copied into a destination range, the source range is not changed.


for_each() 				Performs an operation for each element
copy() 					Copies a range starting with the first element
copy_if() 					Copies elements that match a criterion (since C++11)
copy_n() 					Copies n elements (since C++11)
copy_backward() 				Copies a range starting with the last element
move() 					Moves elements of a range starting with the first element (since C++11)
move_backward() 				Moves elements of a range starting with the last element (since C++11)
transform() 				Modifies (and copies) elements; combines elements of two ranges
merge() 					Merges two ranges
swap_ranges() 				Swaps elements of two ranges
fill() 					Replaces each element with a given value
fill_n() 					Replaces n elements with a given value
generate() 				Replaces each element with the result of an operation
generate_n() 				Replaces n elements with the result of an operation
iota() 					Replaces each element with a sequence of incremented values (since C++11)
replace() 					Replaces elements that have a special value with another value
replace_if() 				Replaces elements that match a criterion with another value
replace_copy() 				Replaces elements that have a special value while copying the whole range
replace_copy_if() 				Replaces elements that match a criterion while copying the whole range



Using transform() is a bit slower because it returns and assigns the result instead of modifying the element directly. However, it is more flexible because it can also be used to modify elements while
they are being copied into a different destination sequence.

Strictly speaking, merge() does not necessarily have to be part of the list of modifying algorithms,because it requires that its input ranges be sorted. So, it should be part of the algorithms for sorted ranges. 
In practice, however, merge() also merges the elements of unsorted ranges. Of course, then the result is unsorted. Nevertheless, to be safe, you should call merge() only for sorted ranges.

Note that elements of associative and unordered containers are constant to ensure that you can’t compromise the sorted order of the elements due to an element modification. Therefore, you can’t
use these containers as a destination for modifying algorithms.



Removing algos:
----------------------
Removing algorithms are a special form of modifying algorithms. They can remove the elements either in a single range or while these elements are being copied into another range. As with modifying
algorithms, you can’t use an associative or unordered container as a destination, because the elements of these containers are considered to be constant.

Note that these algorithms remove elements logically only by overwriting them with the following elements that were not removed. Thus, removing algorithms do not change the number of elements
in the ranges on which they operate. Instead, they return the position of the new “end” of the range. It’s up to the caller to use that new end, such as to remove the elements physically.

remove()				 Removes elements with a given value
remove_if()			 Removes elements that match a given criterion
remove_copy() 			Copies elements that do not match a given value
remove_copy_if() 			Copies elements that do not match a given criterion
unique() 				Removes adjacent duplicates (elements that are equal to their predecessor)
unique_copy() 			Copies elements while removing adjacent duplicates


Mutating algos:
--------------------

Mutating algorithms are algorithms that change the order of elements (and not their values) by assigning and swapping their values.

As with modifying algorithms, you can’t use an associative or unordered container as a destination, because the elements of these containers are considered to be constant.

reverse_copy() 				Copies the elements while reversing their order
rotate() 					Rotates the order of the elements 
rotate_copy()				 Copies the elements while rotating their order
next_permutation() 				Permutates the order of the elements
prev_permutation() 				Permutates the order of the elements 
shuffle() 					Brings the elements into a random order (since C++11)
random_shuffle() 				Brings the elements into a random order
partition() 				Changes the order of the elements so that elements that match a criterion are at the front
stable_partition() 				Same as partition() but preserves the relative order of matching and nonmatching elements
partition_copy() 				Copies the elements while changing the order so that elements that match a criterion are at the front




Stacks:
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
In <stack>, the class stack is defined as follows:
namespace std {
template <typename T,
typename Container = deque<T>>
class stack;
}
The first template parameter is the type of the elements. The optional second template parameter defines the container that the stack uses internally for its elements. The default container is a deque.
It was chosen because, unlike vectors, deques free their memory when elements are removed and don’t have to copy all elements on reallocation.

std::stack<int> st; 						// integer stack
std::stack<int,std::vector<int>> st; 				// integer stack that uses a vector


• push() inserts an element into the stack.
• top() returns the next element in the stack.
• pop() removes an element from the stack.

pop() removes the next element but does not return it, whereas top() returns the next element without removing it. Thus, you must always call both functions to process and remove the
next element from the stack.

the behavior of top() and pop() is undefined if the stack contains no elements. The member functions size() and empty() are provided to check whether the stack contains elements.




Queue:
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

In <queue>, the class queue is defined as follows:
namespace std {
template <typename T,
typename Container = deque<T>>
class queue;
}
The first template parameter is the type of the elements. The optional second template parameter defines the container that the queue uses internally for its elements. The default container is a deque.

std::queue<std::string> buffer; 				// string queue
std::queue<std::string,std::list<std::string>> buffer;

• push() inserts an element into the queue.
• front() returns the next element in the queue (the element that was inserted first).
• back() returns the last element in the queue (the element that was inserted last).
• pop() removes an element from the queue.

pop() removes the next element but does not return it, whereas front() and back() return the element without removing it.

behavior of front(), back(), and pop() is undefined if the queue contains no elements. The member functions size() and empty() are provided to check whether the queue contains elements.

String:
-------------------------------------------------------------------------------------------------------------------------------------------------------

For strings that use wider character sets, such as Unicode or some Asian character sets, three 
other types are predefined (u16string and u32string are provided since C++11):

types:
--------
namespace std {
typedef basic_string<wchar_t> wstring;
typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;
}




Operations on Strings:
-------------------------------
constructors                                                                       Create or copy a string
destructor                                                                           Destroys a string
=, assign()                                                                            Assign a new value
swap()                                                                                  Swaps values between two strings
+=, append(), push_back()                                          Append characters
insert()                                                                                Inserts characters
erase(), pop_back()                                                       Deletes characters (pop_back() since C++11)
clear()                                                                                 Removes all characters (empties a string)
resize()                                                                               Changes the number of characters (deletes or appends characters at the end)
replace()                                                                            Replaces characters
+                                                                                            Concatenates strings
==, !=, <, <=, >, >=, compare()                                    Compare strings
empty()                                                                             Returns whether the string is empty
size(), length()                                                               Return the number of characters
max_size()                                                                       Returns the maximum possible number of characters
capacity()                                                                         Returns the number of characters that can be held without reallocation
reserve()                                                                          Reserves memory for a certain number of characters
shrink_to_fit()                                                                Shrinks the memory for the current number of characters (since C++11)
[ ], at()                                                                               Access a character
front(), back()                                                                Access the first or last character (since C++11)
>>, getline()                                                                    Read the value from a stream
<<                                                                                        Writes the value to a stream
stoi(), stol(), stoll()                                                      Convert string to signed integral value (since C++11)
stoul(), stoull()                                                              Convert string to unsigned integral value (since C++11)
stof(), stod(), stold()                                                   Convert string to floating-point value (since C++11)
to_string(), to_wstring()                                            Convert integral/floating-point value to string (since C++11)
copy()                                                                                Copies or writes the contents to a character array
data(), c_str()                                                                 Returns the value as C-string or character array
substr()                                                                             Returns a certain substring
find functions                                                                 Search for a certain substring or character
begin(), end()                                                                Provide normal iterator support
cbegin(), cend()                                                            Provide constant iterator support (since C++11)
rbegin(), rend()                                                             Provide reverse iterator support
crbegin(), crend()                                                         Provide constant reverse iterator support (since C++11)
get_allocator()                                                               Returns the allocator



atoi(s.c_str())             // convert string into integer




std::string s(’x’);             // ERROR
std::string s(1,’x’);         // OK, creates a string that has one character ’x’
std::string s({’x’});         // OK, ditto (since C++11)


initialize:
-----------
string s                                             Creates the empty string s
string s(str) 		Copy constructor; creates a string as a copy of the existing string str
string s(rvStr)		 Move constructor; creates a string and moves the contents of rvStr to it (rvStr has a valid state with undefined value afterward)
string s(str,stridx) 		Creates a string s that is initialized by the characters of
string str 			starting with index stridx
string s(str,stridx,strlen) 	Creates a string s that is initialized by, at most, strlen characters of string str starting with index stridx
string s(cstr) 		Creates a string s that is initialized by the C-string cstr
string s(chars,charslen) 	Creates a string s that is initialized by charslen characters of the character array chars
string s(num,c)		 Creates a string that has num occurrences of character c
string s(beg,end) 		Creates a string that is initialized by all characters of the range [beg,end)
string s(initlist) 		Creates a string that is initialized by all characters in initlist (since C++11)


erase:
-------
A number of characters when given an offset position and count
string strSample (“Hello String! Wake up to a beautiful day!”);
strSample.erase (13, 28);                                      // Hello String!

A character when supplied with an iterator pointing to it
strSample.erase (iCharS);                                   // iterator points to a specific character

A number of characters given a range supplied by two iterators that bind the same
strSample.erase (strSample.begin (), strSample.end ());                     // erase from begin to end

reverse:
----------
string strSample (“Hello String! We will reverse you!”);
reverse (strSample.begin (), strSample.end ());

transform:
--------------
String case conversion can be effected using the algorithm std::transform, which
applies a user-specified function to every element of a collection.


size() length():
------------------
size_type string::size () const
size_type string::length () const
• Both functions return the current number of characters.
• They are equivalent.
• To check whether the string is empty, you should use empty() because it might be faster

size() and length() are equivalent functions that return the current number of characters of the string


empty():
-----------
bool string::empty () const
• Returns whether the string is empty (contains no characters).
• It is equivalent to string::size()==0, but it might be faster.

The empty() function is a shortcut for checking whether the number of characters is zero.
Thus, it checks whether the string is empty. Because it might be faster, you should use empty() instead of length() or size().

max_size():
---------------

size_type string::max_size () const
• Returns the maximum number of characters a string could contain.
• Whenever an operation results in a string that has a length greater than max_size(), the class
throws length_error.

capacity():
---------------

size_type string::capacity () const
• Returns the number of characters the string could contain without reallocation.

capacity() returns the number of characters a string could contain without having to reallocate its internal memory.



reserve():
------------

void string::reserve ()
void string::reserve (size_type num)
• The first form is a nonbinding shrink-to-fit request.
• The second form reserves internal memory for at least num characters.
• If num is less than the current capacity, the call is taken as a nonbinding request to shrink the capacity.
• If num is less than the current number of characters, the call is taken as a nonbinding request to shrink the capacity to fit the current number of characters (equivalent to the first form).
• The capacity is never reduced below the current number of characters.
• This operation might invalidate references, pointers, and iterators to characters. However, it is guaranteed that no reallocation takes place during insertions that happen after a call to reserve()
until the time when an insertion would make the size greater than num. Thus, reserve() can increase speed and help to keep references, pointers, and iterators valid

s.reserve(); 			// ‘‘would like to shrink capacity to fit the current size’’


shrink_to_fit():
-------------------

void string::shrink_to_fit ()
• Reduces the internal memory to fit the current numbers of characters.
• It has the same effect as reserve(0).
• The call is taken as a nonbinding request to allow latitude for implementation-specific optimizations.
• This operation might invalidate references, pointers, and iterators to characters.
• Available since C++11.

s.shrink_to_fit();			 // ‘‘would like to shrink capacity to fit the current size’’ (C++11)



element access:
--------------------

char& string::operator [ ] (size_type idx)
const char& string::operator [ ] (size_type idx) const
• Both forms return the character with the index idx (the first character has index 0).
• length() or size() is a valid index, and the operator returns the value generated by the default constructor of the character type (for string: ’\0’). 
   Before C++11, length() or size() was an invalid index value for nonconstant strings.
• Passing an invalid index results in undefined behavior.


char& string::at (size_type idx)
const char& string::at (size_type idx) const
• Both forms return the character that has the index idx (the first character has index 0).
• For all strings, an index with length() as value is invalid.
• Passing an invalid index—less than 0 or greater than or equal to length() or size()—throws an out_of_range exception.
• By ensuring that the index is valid, the caller can use operator [ ], which is faster.

char& string::front ()
const char& string::front () const
• Both forms return the first character.
• Calling front() for an empty string returns the value generated by the default constructor of the character type (for string: ’\0’).

char& string::back ()
const char& string::back () const
• Both forms return the last character.
• Calling back() for an empty string results in undefined behavior

Since C++11, front() and back() are provided to also access the first or last character.

If called with an invalid index, at() throws an out_of_range exception. If operator [ ] is called with an invalid index, the behavior is undefined.

front() is equivalent to [0], which means that for empty strings the character representing the end of the string (’\0’ for strings) is returned.
For at(), the current number of characters is not a valid index.
When called for an empty string, back() results in undefined behavior.


s[s.length()]                      // yields ’\0’ (undefined behavior before C++11)
s.at(s.length())                 // throws out_of_range

std::string s("abcde");                           // s contains: ’a’ ’b’ ’c’ ’d’ ’e’
char& r = s[2];                                            // reference to third character
char* p = &s[3];                                          // pointer to fourth character
r = ’X’;                                                            // OK, s contains: ’a’ ’b’ ’X’ ’d’ ’e’
*p = ’Y’;                                                           // OK, s contains: ’a’ ’b’ ’X’ ’Y’ ’e’
s = "new long value";                                // reallocation invalidates r and p
r = ’X’;                                                            // ERROR: undefined behavior
*p = ’Y’;                                                         // ERROR: undefined behavior
To avoid runtime errors, you would have had to reserve() enough capacity before r and p were initialized.

References, pointers, and iterators that refer to characters of a string may be invalidated by the following operations:
• If the value is swapped with swap()
• If a new value is read by operator>>() or getline()
• If any nonconstant member function is called, except operator [ ], at(), begin(), end(), rbegin(), and rend()


const char* string::c_str () const
const char* string::data () const
• Returns the contents of the string as a character array, including a trailing end-of-string character ’\0’. Thus, this is a valid C-string for strings.
• The return value is owned by the string. Thus, the caller must neither modify nor free or delete the return value.
• The return value is valid only as long as the string exists and as long as only constant functions are called for it.
• Before C++11, the return value of data() was guaranteed to contain all characters of the string without any trailing ’\0’ character. Thus, the return value of data() was not a valid C-string.


size_type string::copy (char* buf, size_type buf_size) const
size_type string::copy (char* buf, size_type buf_size, size_type idx) const
• Both forms copy at most buf_size characters of the string (beginning with index idx, if passed) into the character array buf.
• They return the number of characters copied.
• No null character is appended. Thus, the contents of buf might not be a valid C-string after the call.
• The caller must ensure that buf has enough memory; otherwise, the call results in undefined behavior.
• Throws out_of_range if idx > size().

compare:
---------------

The compare() member functions can process more than one argument for each string, so you can specify a substring by its index and its length.
This return value has the following meaning: 0 means equal, a value less than 0 means less than,and a value greater than 0 means greater than.

std::string s("abcd");
s.compare("abcd")                                                    // returns 0
s.compare("dcba")                                                  // returns a value < 0 (s is less)
s.compare("ab")                                                 // returns a value > 0 (s is greater)
s.compare(s)                                                           // returns 0 (s is equal to s)
s.compare(0,2,s,2,2)                                        // returns a value < 0 ("ab" is less than "cd")  (need to specify position and length when using a variable) (first two args. are of the string with which the function is being called)
s.compare(1,2,"bcx",2)                                  // returns 0 ("bc" is equal to "bc") (just need length when explicitly given the string default position is taken as  0)

empty string:
-------------------
s = "";                    // assign the empty string
s.clear();              // clear contents
s.erase();             // erase all characters


modifiers:
--------------

To modify a string, you can use operator = to assign a new value

s.assign(aString);                                                                        // assign "othello" (equivalent to operator =)
s.assign(aString,1,3); 			// assign "the"
s.assign(aString,2,std::string::npos);		 // assign "hello"
s.assign("two\nlines");			 // assign a C-string (equivalent to operator =)
s.assign("nico",5); 				// assign the character array: ’n’ ’i’ ’c’ ’o’ ’\0’
s.assign(5,’x’);				 // assign five characters: ’x’ ’x’ ’x’ ’x’ ’x’

insert,remove,replace character:
--------------------------

const std::string aString("othello");
std::string s;
s += aString; 				// append "othello"
s += "two\nlines";				 // append C-string
s += ’\n’; 					// append single character
s += { ’o’, ’k’ };				 // append an initializer list of characters (since C++11)
s.append(aString);				 // append "othello" (equivalent to operator +=)
s.append(aString,1,3); 			// append "the"
s.append(aString,2,std::string::npos); 		// append "hello"
s.append("two\nlines"); 			// append C-string (equivalent to operator +=)
s.append("nico",5);				 // append character array: ’n’ ’i’ ’c’ ’o’ ’\0’
s.append(5,’x’);				 // append five characters: ’x’ ’x’ ’x’ ’x’ ’x’
s.push_back(’\n’); 				// append single character (equivalent to operator +=)

std::string s = "i18n"; 			// s: i18n
s.replace(1,2,"nternationalizatio");		 // s: internationalization
s.erase(13); 				// s: international
s.erase(7,5); 				// s: internal
s.pop_back(); 				// s: interna (since C++11)
s.replace(0,2,"ex"); 				// s: externa

insert():
----------
These functions require the index of the character, after which the new characters are inserted:

const std::string aString("age");
std::string s("p");
s.insert(1,aString); 		// s: page
s.insert(1,"ersifl"); 		// s: persiflage

no insert() member function is provided to pass the index and a single character. Thus, you must pass a string or an additional number:
s.insert(0,’ ’); 		// ERROR
s.insert(0," "); 		// OK

s.insert(0,1,’ ’); // ERROR: ambiguous

However, this results in a nasty ambiguity because insert() is overloaded for the following signatures:

insert (size_type idx, size_type num, charT c);		 // position is index
insert (iterator pos, size_type num, charT c);		 // position is iterator
For type string, size_type is usually defined as unsigned, and iterator is often defined as char*. 
In this case, the first argument 0 has two equivalent conversions. So, to get the correct behavior, you have to write:
s.insert((std::string::size_type)0,1,’ ’); 			// OK

substring:
------------
std::string s("interchangeability");
s.substr() 						// returns a copy of s
s.substr(11) 					// returns string("ability")(position)
s.substr(5,6) 					// returns string("change")(position,length)
s.substr(s.find(’c’))					 // returns string("changeability")


can use operator + to concatenate two strings or C-strings:

std::string s1("enter");
std::string s2("nation");
std::string i18n;
i18n = ’i’ + s1.substr(1) + s2 + "aliz" + s2.substr(1);
std::cout << "i18n means: " + i18n << std::endl;
have the following output:  "i18n means: internationalization"

getline():
--------------

This function reads all characters, including leading whitespaces, until the line delimiter or end-of-file is reached.

By default, the line delimiter is the newline character, but you can pass your own “line” delimiter as an optional argument.
This way, you can read token by token, separated by any arbitrary character:

std::string s;
while (getline(std::cin,s)) { // for each line read from cin
...
}
while (getline(std::cin,s,’:’)) { // for each token separated by ’:’
...
}

string p,q;
getline(cin,p);   			// without delimiter
getline(cin,q,cin.widen(' '));  		//with delimiter
cout<<p<<q;


searching():
------------------

find() 				Finds the first occurrence of value
rfind() 				Finds the last occurrence of value (reverse find)
find_first_of() 			Finds the first character that is part of value
find_last_of() 			Finds the last character that is part of value
find_first_not_of() 			Finds the first character that is not part of value
find_last_not_of() 			Finds the last character that is not part of value

All search functions return the index of the first character of the character sequence that matches the search. If the search fails, they return npos.
• The first argument is always the value that is searched for.
• The second optional value indicates an index at which to start the search in the string.
• The optional third argument is the number of characters of the value to search.


std::string s("Hi Bill, I’m ill, so please pay the bill");
s.find("il") 			// returns 4 (first substring "il")
s.find("il",10)			// returns 13 (first substring "il" starting from s[10])
s.rfind("il") 			// returns 37 (last substring "il")
s.find_first_of("il")			// returns 1 (first char ’i’ or ’l’)
s.find_last_of("il") 			// returns 39 (last char ’i’ or ’l’)
s.find_first_not_of("il") 		// returns 0 (first char neither ’i’ nor ’l’)
s.find_last_not_of("il") 		// returns 36 (last char neither ’i’ nor ’l’)
s.find("hi") 			// returns npos

When you want to check the return value, always use string::size_type, not int or unsigned for the type of the return value.

string::npos
-----------------
std::string s;
std::string::size_type idx; // be careful: don’t use any other type!
...
idx = s.find("substring");
if (idx == std::string::npos) {
...
}

(futher reading required)


Numeric conversion:
-----------------------------

that these conversions are available only for types string and wstring, not u16string and u32string.

stoi(str,idxRet=nullptr, base=10) 			Converts str to an int
stol(str,idxRet=nullptr, base=10) 			Converts str to a long
stoul(str,idxRet=nullptr, base=10) 			Converts str to an unsigned long
stoll(str,idxRet=nullptr, base=10) 			Converts str to a long long
stoull(str,idxRet=nullptr, base=10) 			Converts str to an unsigned long long
stof(str,idxRet=nullptr) 				Converts str to a float
stod(str,idxRet=nullptr) 				Converts str to a double
stold(str,idxRet=nullptr) 				Converts str to a long double
to_string(val) 					Converts val to a string
to_wstring(val) 					Converts val to a wstring


For all function that convert strings to a numeric value, the following applies:
• They skip leading whitespaces.
• They allow you to return the index of the first character after the last processed character.
• They might throw std::invalid_argument if no conversion is possible and std::out_of_range if the converted value is outside the range of representable values for the return type.
• For integral values, you can optionally pass the number base to use.

For all functions that convert a numeric value to a string or wstring, val may be any of the following types: int, unsigned int, long, unsigned long, long long, unsigned long long, float, double, or long double.



Streams:
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

C/C++ IO are based on streams, which are sequence of bytes flowing in and out of the programs (just like water and oil flowing through a pipe). 
In input operations, data bytes flow from an input source (such as keyboard, file, network or another program) into the program. 
In output operations, data bytes flow from the program to an output sink (such as console, file, network or another program). 
Streams acts as an intermediaries between the programs and the actual IO devices.


C++ provides both the formatted and unformatted IO functions. In formatted or high-level IO, bytes are grouped and converted to types such as int, double, string or user-defined types.
In unformatted or low-level IO, bytes are treated as raw bytes and unconverted. Formatted IO operations are supported via overloading the stream insertion (<<) and stream extraction (>>) operators,
which presents a consistent public IO interface.

To perform input and output, a C++ program:
1. Construct a stream object.
2. Connect (Associate) the stream object to an actual IO device (e.g., keyboard, console, file, network, another program).
3. Perform input/output operations on the stream, via the functions defined in the stream's pubic interface in a device independent manner. Some functions convert the data
     between the external format and internal format (formatted IO); while other does not (unformatted or binary IO).
4. Disconnect (Dissociate) the stream to the actual IO device (e.g., close the file).
5. Free the stream object.

C++ IO is provided in headers <iostream> (which included <ios>, <istream>, <ostream> and <streambuf>), <fstream> (for file IO), and <sstream> (for string IO).
The header <iomanip> provided manipulators such as setw(), setprecision()setfill() and setbase() for formatting.


1. ios_base and ios: superclasses to maintain common stream properties such as format flag, field width, precision and locale. The superclass ios_base (which is not a template class) maintains 
     data that is independent of the template parameters;whereas the subclass ios (instantiation of template basic_ios<char>) maintains data which is dependent of the template parameters.
2. istream (basic_istream<char>), ostream (basic_ostream<char>): provide the input and output public interfaces.
3. iostream (basic_iostream<char>): subclass of both istream and ostream, which supports bidirectional input and output operations. Take note that istream and ostream are unidirectional streams; 
     whereas iostream is bidirectional. basic_iostream template and iostream class is declared in the <istream> header, not <iostream> header.
4. ifstream, ofstream and fstream: for file input, output and bidirectional input/output.
5. istringstream, ostringstream and stringstream: for string buffer input, output and bidirectional input/output.
6. streambuf, filebuf and stringbuf: provide memory buffer for the stream, file-stream and string-stream, and the public interface for accessing and managing the buffer.


The Stream Insertion << and Stream Extraction >> Operators:
--------------------------------------------------------------------------

Formatted output is carried out on streams via the stream insertion << and stream extraction >> operators.
The << and >> operators are overloaded to handle fundamental types (such as int and double), and classes (such as string).


ostream Class:
--------------------

The ostream class is a typedef to basic_ostream<char>. It contains two set of output functions: formatted output and unformatted output.
The formatted output functions (via overloaded stream insertion operator <<) convert numeric values (such as int, double) from their internal representations (e.g., 16-/32-bit int, 64-bit double) to a stream of characters that representing the numeric values in text form.
The unformatted output functions (e.g., put(), write()) outputs the bytes as they are, without format conversion.

The ostream class overloads the stream insertion << operator for each of the C++ fundamental types.

The << operator returns a reference to the invoking ostream object. Hence, you can concatenate << operations, e.g., cout << 123 << 1.13 << endl;.
The << operator is also overloaded for the following pointer types:
const char *, const signed char *, const unsigned char *: for outputting C-strings and literals. It uses the terminating null character to decide the end of the char array.
void *: can be used to print an address.

You can flush the output buffer via:
flush member function or manipulator:
// Member function of ostream class - std::ostream::flush
ostream & flush ();
// Example
cout << "hello";
cout.flush();
 
// Manipulator - std::flush
ostream & flush (ostream & os);
// Example
cout << "hello" << flush;
endl manipulator, which inserts a newline and flush the buffer. Outputting a newline character '\n' may not flush the output buffer; but endl does.

cin: output buffer is flushed when input is pending, e.g.,
cout << "Enter a number: ";
int number;
cin << number;  // flush output buffer so as to show the prompting message



istream Class:
------------------

the istream class is a typedef to basic_istream<char>. It also supports formatted input and unformatted input.
In formatting input, via overloading the >> extraction operator, it converts the text form (a stream of character) into internal representation (such as 16-/32-bit int, 64-byte double).
In unformatting input, such as get(), getline(), read(), it reads the characters as they are, without conversion.
The >> operator returns a reference to the invokind istream object. Hence, you can concatenate >> operations.

You can use the ignore() to discard characters in the input buffer:
istream & ignore (int n = 1, int delim = EOF);
    // Read and discard up to n characters or delim, whichever comes first
 
// Examples
cin.ignore(numeric_limits<streamsize>::max());        // Ignore to the end-of-file
cin.ignore(numeric_limits<streamsize>::max(), '\n');  // Ignore to the end-of-line

Unformatted Input/Output Functions:
-----------------------------------------------

put():
The ostream's member function put() can be used to put out a char. put() returns the invoking ostream reference, and thus, can be cascaded.
cout.put('A').put('p').put('p').put('\n');


get(),getline():

int get ();   
      // Get a char and return as int. It returns EOF at end-of-file
istream & get (char & c);
      // Get a char, store in c and return the invoking istream reference
 
// C-string input
istream & get (char * cstr, streamsize n, char delim = '\n');
      // Get n-1 chars or until delimiter and store in C-string array cstr.
      // Append null char to terminate C-string
      // Keep the delim char in the input stream.
istream & getline (char * cstr, streamsize n, char delim = '\n');
      // Same as get(), but extract and discard delim char from the
      // input stream.



read(),write(),gcount():

// istream class
istream & read (char * buf, streamsize n);
      // Read n characters from istream and keep in char array buf.
      // Unlike get()/getline(), it does not append null char at the end of input.
      // It is used for binary input, instead of C-string.
streamsize gcount() const;
      // Return the number of character extracted by the last unformatted input operation
      // get(), getline(), ignore() or read().
 
// ostream class
ostream & write (const char * buf, streamsize n)
      // Write n character from char array

peek(),putback():

char peek ();
      //returns the next character in the input buffer without extracting it.
 
istream & putback (char c);
      // insert the character back to the input buffer.

States of Stream:
-----------------------

eofbit: set when an input operation reaches end-of-file.
failbit: The last input operation failed to read the expected characters or output operation failed to write the expected characters, e.g., getline() reads n characters without reaching delimiter character.
badbit: serious error due to failure of an IO operation (e.g. file read/write error) or stream buffer.
goodbit: Absence of above error with value of 0.


These flags are defined as public static members in ios_base. They can be accessed directly via ios_base::failbit or via subclasses such as cin::failbit, ios::failbit. However, it is more convenience to use these public member functions of ios class:
good(): returns true if goodbit is set (i.e., no error).
eof(): returns true if eofbit is set.
fail(): returns true if failbit or badbit is set.
bad(): returns true if badbit is set.
clear(): clear eofbit, failbit and badbit



C++ provides a set of manipulators to perform input and output formatting:
<iomanip> header: setw(), setprecision(), setbas(), setfill().
<iostream> header: fixed|scientific, left|right|internal, boolalpha|noboolalpha, etc

Field Width (setw), Fill Character (setfill) and Alignment (left|right|internal):

The ios_base superclass (included in <iostream> header) maintains data members for field-width (width) and formatting flags (fmtflags); and provides member functions (such as width(), setf()) for manipulating them.
However, it is more convenience to use the so-called IO manipulators, which returns a reference to the invoking stream object and thus can be concatenated in << operator (e.g., cout << setfill(':') << left << setw(5) <<...). They are:
setw() manipulator (in <iomanip> header) to set the field width.
setfill() manipulator (in <iomanip> header) to set the fill character
left|right|internal manipulator (in <iostream> header) to set the text alignment.
The default field-width is 0, i.e., just enough space to display the value. C++ never truncates data, and will expand the field to display the entire value if the field-width is too small. The setw() operation is non-sticky. That is, it is applicable only to the next IO operation, and reset back to 0 after the operation. The field-width property is applicable to both output and input operations.
Except setw(), all the other IO manipulators are sticky, i.e., they take effect until a new value is set.
// Test setw() - need <iomanip>
cout << "|" << setw(5) << 123 << "|" << 123 << endl;  // |  123|123
         // setw() is non-sticky. "|" and 123 displayed with default width
cout << "|" << setw(5) << -123 << "|" << endl;        // | -123|123
         // minus sign is included in field width
cout << "|" << setw(5) << 1234567 << "|" << endl;     // |1234567|
         // no truncation of data
 
// Test setfill() and alignment (left|right|internal)
cout << setfill('_');   // Set the fill character (sticky)
cout << setw(6) << 123 << setw(4) << 12 << endl;      // ___123__12
cout << left;           // left align (sticky)
cout << setw(6) << 123 << setw(4) << 12 << endl;      // 123___12__
Example: Alignment
cout << showpos;  // show positive sign
cout             << '|' << setw(6) << 123 << '|' << endl;  // |  +123| (default alignment)
cout << left     << '|' << setw(6) << 123 << '|' << endl;  // |+123  |
cout << right    << '|' << setw(6) << 123 << '|' << endl;  // |  +123|
cout << internal << '|' << setw(6) << 123 << '|' << endl;  // |+  123|

The internal alignment left-align the sign, but right-align the number, as illustrated.

You can also use ostream's member function width() (e.g. cout.width(n)) to set the field width, but width() cannot be used with cout << operator.


Floating-point Format (fixed|scientific) and Precision (setprecision):
The IO stream superclass ios_base also maintains data member for the floating-point precision and display format; and provides member functions (such as precision()) for manipulating them.
Again, it is more convenience to use IO manipulators, which can be concatenated in <<. They are:
setprecision() manipulator (in <iomanip> header) to set the precision of floating-point number.
fixed|scientific manipulators (in <iostream> header) to set the floating-point display format.
Floating point number can be display in 3 formatting modes: default|fixed|scientific. The precision is interpreted differently in default and non-default modes (due to legacy).
In default mode (neither fixed nor scientific used), a floating-point number is displayed in fixed-point notation (e.g., 12.34) for exponent in the range of [-4, 5]; and scientific notation (e.g., 1.2e+006) otherwise. The precision in default mode includes digits before and after the decimal point but exclude the leading zeros. Fewer digits might be shown as the trailing zeros are not displayed. The default precision is 6. See the earlier examples for default mode with default precision of 6.
As mentioned, the trailing zeros are not displayed in default mode, you can use manipulator showpoint|noshowpoint to show or hide the trailing zeros.
In both fixed (e.g., 12.34) and scientific (e.g., 1.2e+006), the precision sets the number of digits after decimal point. The default precision is also 6.
For examples,
// default floating-point format
cout << "|" << 123.456789 << "|" << endl;    // |123.457| (fixed-point format)
         // default precision is 6, i.e., 6 digits before and after the decimal point
cout << "|" << 1234567.89 << "|" << endl;    // |1.23457e+006| (scientific-notation for e>=6)
         // default precision is 6, i.e., 6 digits before and after the decimal point
 
// showpoint - show trailing zeros in default mode
cout << showpoint << 123. << "," << 123.4 << endl; // 123.000,123.400
cout << noshowpoint << 123. << endl;               // 123
 
// fixed-point formatting
cout << fixed;
cout << "|" << 1234567.89 << "|" << endl;    // |1234567.890000|
         // default precision is 6, i.e., 6 digits after the decimal point
 
// scientific formatting
cout << scientific;   
cout << "|" << 1234567.89 << "|" << endl;    // |1.234568e+006|
         // default precision is 6, i.e., 6 digits after the decimal point
 
// Test precision
cout << fixed << setprecision(2);   // sticky
cout << "|" << 123.456789 << "|" << endl;  // |123.46|
cout << "|" << 123. << "|" << endl;        // |123.00|
 
cout << setprecision(0);
cout << "|" << 123.456789 << "|" << endl;  // |123|
You can also use ostream's member function precision(n) (e.g. cout.precision(n)) to set the floating-point precision, but precision() cannot be used with cout << operator.


Integral Number Base (dec|oct|hex, setbase):
C++ support number bases (radixes) of decimal, hexadecimal and octal. You can use the following manipulators (defined in ios_base class, included in <iostream> header) to manipulate the integral number base:
hex|dec|oct: Set the integral number base. Negative hex and oct are displayed in 2's complement format. Alternatively, you can use setbase(8|10|16) (in header <iomanip>).
showbase|noshowbase: write hex values with 0x prefix; and oct values with 0 prefix.
showpos|noshowpos: write positive dec value with + sign.
uppercase|nouppercase: write uppercase in certain insertion operations, e.g., hex digits. It does not convert characters or strings to uppercase!
These manipulators are sticky.
For examples,
cout << 1234 << endl;        // 1234 (default is dec)
cout << hex << 1234 << endl; // 4d2
cout << 1234 << "," << -1234 << endl; // 4d2,fffffb2e
                                      // (hex is sticky, negative number in 2's complement)
cout << oct << 1234 << endl;          // 2322
cout << 1234 << "," << -1234 << endl; // 2322,37777775456
cout << setbase(10) << 1234 << endl;  // 1234 (setbase requires <iomanip> header)
 
// showbase - show hex with 0x prefix; oct with 0 prefix
cout << showbase << 123 << "," << hex << 123 << "," << oct << 123 << endl;  // 123,0x7b,0173
cout << noshowbase << dec;
 
// showpos - show dec's plus (+) sign
cout << showpos << 123 << endl;  // +123
 
// uppercase - display in uppercase (e.g., hex digits)
cout << uppercase << hex << 123 << endl;  // 7B




bool values (boolalpha|noboolalpha):
boolalpha|noboolalpha: read/write bool value as alphabetic string true or false.
// boolalpha - display bool as true/false
cout << boolalpha << false << "," << true << endl;   // false,true
cout << noboolalpha << false << "," << true << endl; // 0,1

Other manipulators:
skipws|noskipws: skip leading white spaces for certain input operations.
unitbuf|nounibuf: flush output after each insertion operation.

Notes:
You need to include the <iomanip> header for setw(), setprecision(), setfill(), and setbase().
You can use ios_base's (in <iostream> header) member functions setf() and unsetf() to set the individual formatting flags. However, they are not as user-friendly as using manipulators as discussed above. Furthermore, they cannot be used with cout << operator.

FILE:
-------

In header <fstream>, the class ofstream is a subclass of ostream; ifstream is a subclass of istream; and fstream is a subclass of iostream for bi-directional IO. You need to include both <iostream> and <fstream> headers in your program for file IO.
To write to a file, you construct a ofsteam object connecting to the output file, and use the ostream functions such as stream insertion <<, put() and write(). Similarly, to read from an input file, construct an ifstream object connecting to the input file, and use the istream functions such as stream extraction >>, get(), getline() and read().



FILE OUTPUT:
-----
The steps are:
Construct an ostream object.
Connect it to a file (i.e., file open) and set the mode of file operation (e.g, truncate, append).
Perform output operation via insertion >> operator or write(), put() functions.
Disconnect (close the file which flushes the output buffer) and free the ostream object.
#include <fstream>
.......
ofstream fout;
fout.open(filename, mode);
......
fout.close();
 
// OR combine declaration and open()
ofstream fout(filename, mode);
By default, opening an output file creates a new file if the filename does not exist; or truncates it (clear its content) and starts writing as an empty file.
open(), close() and is_open()
void open (const char* filename,
           ios::openmode mode = ios::in | ios::out);
   // open() accepts only C-string. For string object, need to use c_str() to get the C-string
 
void close ();    // Closes the file, flush the buffer and disconnect from stream object
 
bool is_open ();  // Returns true if the file is successfully opened


File Modes:
File modes are defined as static public member in ios_base superclass. They can be referenced from ios_base or its subclasses - we typically use subclass ios. The available file mode flags are:
ios::in - open file for input operation
ios::out - open file for output operation
ios::app - output appends at the end of the file.
ios::trunc - truncate the file and discard old contents.
ios::binary - for binary (raw byte) IO operation, instead of character-based.
ios::ate - position the file pointer "at the end" for input/output.
You can set multiple flags via bit-or (|) operator, e.g., ios::out | ios::app to append output at the end of the file.
For output, the default is ios::out | ios::trunc. For input, the default is ios::in.


FILE INPUT:
The steps are:
Construct an istream object.
Connect it to a file (i.e., file open) and set the mode of file operation.
Perform output operation via extraction << operator or read(), get(), getline() functions.
Disconnect (close the file) and free the istream object.
#include <fstream>
.......
ifstream fin;
fin.open(filename, mode);
......
fin.close();
 
// OR combine declaration and open()
ifstream fin(filename, mode);


SAMPLE CODE:
/* Testing Simple File IO (TestSimpleFileIO.cpp) */
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <string>
using namespace std;
 
int main() {
   string filename = "test.txt";
 
   // Write to File
   ofstream fout(filename.c_str());  // default mode is ios::out | ios::trunc
   if (!fout) {
      cerr << "error: open file for output failed!" << endl;
      abort();  // in <cstdlib> header
   }
   fout << "apple" << endl;
   fout << "orange" << endl;
   fout << "banana" << endl;
   fout.close();
 
   // Read from file
   ifstream fin(filename.c_str());  // default mode ios::in
   if (!fin) {
      cerr << "error: open file for input failed!" << endl;
      abort();
   }
   char ch;
   while (fin.get(ch)) {  // till end-of-file
      cout << ch;
   }
   fin.close();
   return 0;
}
Program Notes:
Most of the <fstream> functions (such as constructors, open()) supports filename in C-string only. You may need to extract the C-string from string object via the c_str() member function.
You could use is_open() to check if the file is opened successfully.
The get(char &) function returns a null pointer (converted to false) when it reaches end-of-file

We need to use read() and write() member functions for binary file (file mode of ios::binary), which read/write raw bytes without interpreting the bytes.


SAMPLE CODE:
/* Testing Binary File IO (TestBinaryFileIO.cpp) */
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <string>
using namespace std;
 
int main() {
   string filename = "test.bin";
 
   // Write to File
   ofstream fout(filename.c_str(), ios::out | ios::binary);
   if (!fout.is_open()) {
      cerr << "error: open file for output failed!" << endl;
      abort();
   }
   int i = 1234;
   double d = 12.34;
   fout.write((char *)&i, sizeof(int));
   fout.write((char *)&d, sizeof(double));
   fout.close();
 
   // Read from file
   ifstream fin(filename.c_str(), ios::in | ios::binary);
   if (!fin.is_open()) {
      cerr << "error: open file for input failed!" << endl;
      abort();
   }
   int i_in;
   double d_in;
   fin.read((char *)&i_in, sizeof(int));
   cout << i_in << endl;
   fin.read((char *)&d_in, sizeof(double));
   cout << d_in << endl;
   fin.close();
   return 0;
}



Random Access File:

Random access file is associated with a file pointer, which can be moved directly to any location in the file. Random access is crucial in certain applications such as databases and indexes.
You can position the input pointer via seekg() and output pointer via seekp(). Each of them has two versions: absolute and relative positioning.
// Input file pointer (g for get)
istream & seekg (streampos pos);  // absolute position relative to beginning
istream & seekg (streamoff offset, ios::seekdir way);
      // with offset (positive or negative) relative to seekdir:
      // ios::beg (beginning), ios::cur (current), ios::end (end)
streampos tellg ();  // Returns the position of input pointer

// Output file pointer (p for put)
ostream & seekp (streampos pos);  // absolute
ostream & seekp (streamoff offset, ios::seekdir way);  // relative
streampos tellp ();   // Returns the position of output pointer
Random access file is typically process as binary file, in both input and output modes.


STRING STREAMS:
-------------------------

The string streams is based on ostringstream (subclass of ostream), istringstream (subclass of istream) and bi-directional stringstream (subclass of iostream).
typedef basic_istringstream<char> istringstream;
typedef basic_ostringstream<char> ostringstream;
Stream input can be used to validate input data; stream output can be used to format the output.


ostringstream
explicit ostringstream (ios::openmode mode = ios::out);  // default with empty string
explicit ostringstream (const string & buf, 
                        ios::openmode mode = ios::out);  // with initial str

string str () const;           // Get contents
void str (const string & str); // Set contents
For example,
// construct output string stream (buffer) - need <sstream> header
ostringstream sout;  
    
// Write into string buffer
sout << "apple" << endl;
sout << "orange" << endl;
sout << "banana" << endl;
 
// Get contents
cout << sout.str() << endl;
The ostringstream is responsible for dynamic memory allocation and management.


istringstream
explicit istringstream (ios::openmode mode = ios::in);  // default with empty string
explicit istringstream (const string & buf,
                        ios::openmode mode = ios::in);  // with initial string
For example,
// construct input string stream (buffer) - need <sstream> header
istringstream sin("123 12.34 hello");
 
// Read from buffer
int i;
double d;
string s;
sin >> i >> d >> s;
cout << i << "," << d << "," << s << endl;






FastIO:

void fastscan(long long int &x){
        bool neg=false;
        register int c;
        x =0;
        c=getchar();
        if(c=='-'){
            neg = true;
            c=getchar();
        }
        for(;(c>47 && c<58);c=getchar()) x = (x<<1) + (x<<3) +c -48;
        if(neg) x *=-1;
}

void fastRead_string(char *str)
{
    register char c=0;
    register int i = 0;
    while (c < 33)
        c = getchar_unlocked();
    while (c > 65)
    {
        str[i] = c;
        c = getchar_unlocked();
        i = i + 1;
    }

    str[i] = '\0';
}


DOBUTs:
--------------------
string::npos;
operator + is also overloaded for strings that are rvalue references to support the move semantics.
Thus, if a string argument passed to operator + is no longer needed afterward, you should use move() to pass it to the operator.
----------------------------------------------






























